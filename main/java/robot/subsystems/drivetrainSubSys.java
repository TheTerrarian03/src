// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package robot.subsystems;

import robot.commands.*;
import robot.Constants;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.Timer;

import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class drivetrainSubSys extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonFX leftMotor1;
private WPI_TalonFX leftMotor2;
private MotorControllerGroup leftMotorGrp;
private WPI_TalonFX rightMotor1;
private WPI_TalonFX rightMotor2;
private MotorControllerGroup rightMotorGrp;
private DifferentialDrive driveCtrl;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private AHRS gyro = new AHRS(SPI.Port.kMXP);

    private static final double GYROCORRLIMIT = 0.5;
    private static final double GYROCORRCNST =  0.5;

    private static Timer driveTimer = new Timer();
    private double avgVelMinus1 = 0;
    private double avgVelMinus2 = 0;
    private double avgVelMinus3 = 0;
    private double lastTime =     0;
    private double avgVelocity =  0;
    private double lastDist =     0;
    private double currDist =     0;

    public drivetrainSubSys() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftMotor1 = new WPI_TalonFX(1);
 
 

leftMotor2 = new WPI_TalonFX(2);
 
 

leftMotorGrp = new MotorControllerGroup(leftMotor1, leftMotor2  );
 addChild("LeftMotorGrp",leftMotorGrp);
 

rightMotor1 = new WPI_TalonFX(3);
 
 

rightMotor2 = new WPI_TalonFX(4);
 
 

rightMotorGrp = new MotorControllerGroup(rightMotor1, rightMotor2  );
 addChild("RightMotorGrp",rightMotorGrp);
 

driveCtrl = new DifferentialDrive(leftMotorGrp, rightMotorGrp);
 addChild("DriveCtrl",driveCtrl);
 driveCtrl.setSafetyEnabled(true);
driveCtrl.setExpiration(0.1);
driveCtrl.setMaxOutput(1.0);



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    leftMotorGrp.setInverted(true);

    leftMotor1.setNeutralMode(NeutralMode.Brake);
    leftMotor2.setNeutralMode(NeutralMode.Brake);
    rightMotor1.setNeutralMode(NeutralMode.Brake);
    rightMotor2.setNeutralMode(NeutralMode.Brake);

    initEncoders();
    driveTimer.reset();
    driveTimer.start();

    
}
    //private double k_EncConvConst = 0.0010475;

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        updateCurrentVelocity();
        updateShuffleboard();
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void stop() {
        driveCtrl.arcadeDrive(0, 0);
    }
    public void curveDrive(double speed, double rotation, boolean inplace ){
        driveCtrl.curvatureDrive(speed, rotation, inplace);
    }

    public void arcadeDrive(double speed, double rotation){
        driveCtrl.arcadeDrive(speed, rotation);
    }

    public void tankDrive(double leftSpeed, double rightSpeed){
        driveCtrl.tankDrive(leftSpeed, rightSpeed);
    }

    public void driveStraightToHdg(double pwr, double targetYaw) {
        double motorAngle = calcArcadeGyroCorrection(targetYaw);
        driveCtrl.arcadeDrive(-pwr, -motorAngle);
    }

    //---------------------------------------------------\\
    //--------------------Gyro Methods-------------------\\
    public void resetGyro(){
        gyro.reset();
    }

    public double getGyroYaw(){
        return gyro.getYaw();
    }

    public double getGyroRate() {
        return gyro.getRate();
    }

    //---------Calculate Gyro Corrected Angle------------\\
    private double calcArcadeGyroCorrection(double tgtYaw) {
        double yawError = tgtYaw - getGyroYaw();
        if (yawError > 180)     { yawError -= 360; }
        if (yawError < -180)    { yawError += 360; }
        double correctionValue = yawError * GYROCORRCNST;

        if (correctionValue > GYROCORRLIMIT) {
            correctionValue = GYROCORRLIMIT;
        } else if (correctionValue < -GYROCORRLIMIT){
            correctionValue = -GYROCORRLIMIT;
        }
        return correctionValue;
    }

    //----------------------------------------------------\\
    //----------------------Velocity----------------------\\

    private void updateCurrentVelocity(){
        double time, delta_Time, delta_Dist, currVel;
        time = driveTimer.get();
        delta_Time = time - lastTime;
        lastTime = time;
        if (delta_Time == 0) { delta_Time = 0.00000001; }

        currDist = getAvgEncoderDist();
        delta_Dist = currDist - lastDist;
        currVel = delta_Dist / delta_Time;

        avgVelocity = (currVel + avgVelMinus1 + avgVelMinus2 + avgVelMinus3) / 4;

        avgVelMinus3 = avgVelMinus2;
        avgVelMinus2 = avgVelMinus1;
        avgVelMinus1 = avgVelocity;
    }

    //---------------------------------------------------\\
    //-------------------Encoder Methods-----------------\\

    public void initEncoders() {
        leftMotor1.setSensorPhase(true);
        rightMotor1.setSensorPhase(false);
    }

    public void resetEncoders(){                    // Set Encoders to zero
        rightMotor1.setSelectedSensorPosition(0,0,10);
        leftMotor1.setSelectedSensorPosition(0,0,10);
    }


    public int getLeftEncoder()                 { return (int)-leftMotor1.getSelectedSensorPosition(0); }
    public int getRightEncoder()                { return (int)rightMotor1.getSelectedSensorPosition(0); }

    public double getLeftEncoderDist()          { return (getLeftEncoder() *  Constants.k_EncConvConst); }
    public double getRightEncoderDist()         { return (getRightEncoder() * Constants.k_EncConvConst); }
    
    public double getAvgEncoderDist()           { return ((getLeftEncoderDist() + getRightEncoderDist()) / 2.0 ); }
    public double getCurrentVel()               { return avgVelocity; }
    public double getCurrentDist()              { return currDist; }

    //------------------------------------------------\\
    //-------------------Shuffleboard-----------------\\
    private void updateShuffleboard() {
        SmartDashboard.putNumber("Enc-Left Cnt", getLeftEncoder());
        SmartDashboard.putNumber("Enc-Left Dist", getLeftEncoderDist());
    
        SmartDashboard.putNumber("Enc-Right Cnt", getRightEncoder());
        SmartDashboard.putNumber("Enc-Right Dist", getRightEncoderDist());

        SmartDashboard.putNumber("Avg Dist", getAvgEncoderDist());
        SmartDashboard.putNumber("Velocity", getCurrentVel());
        
        SmartDashboard.putNumber("Gyro Yaw", getGyroYaw());
        SmartDashboard.putNumber("Gyro Rate", getGyroRate());
    }
}

